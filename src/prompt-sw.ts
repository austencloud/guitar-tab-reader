import { cleanupOutdatedCaches, createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { NavigationRoute, registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare let self: ServiceWorkerGlobalScope;

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
	({ url }) => url.origin === 'https://fonts.googleapis.com',
	new StaleWhileRevalidate({
		cacheName: 'google-fonts-stylesheets'
	})
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
	({ url }) => url.origin === 'https://fonts.gstatic.com',
	new CacheFirst({
		cacheName: 'google-fonts-webfonts',
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200]
			}),
			new ExpirationPlugin({
				maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
				maxEntries: 30
			})
		]
	})
);

// Cache images with a cache-first strategy
registerRoute(
	({ request }) => request.destination === 'image',
	new CacheFirst({
		cacheName: 'images',
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200]
			}),
			new ExpirationPlugin({
				maxEntries: 60,
				maxAgeSeconds: 30 * 24 * 60 * 60 // 30 Days
			})
		]
	})
);

// Cache CSS, JS, and Web Worker requests with a stale-while-revalidate strategy
registerRoute(
	({ request }) =>
		request.destination === 'style' ||
		request.destination === 'script' ||
		request.destination === 'worker',
	new StaleWhileRevalidate({
		cacheName: 'static-resources'
	})
);

// Cache API requests with a network-first strategy
registerRoute(
	({ url }) => url.pathname.startsWith('/api/'),
	new NetworkFirst({
		cacheName: 'api-cache',
		plugins: [
			new CacheableResponsePlugin({
				statuses: [0, 200]
			}),
			new ExpirationPlugin({
				maxEntries: 50,
				maxAgeSeconds: 5 * 60 // 5 minutes
			})
		]
	})
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
	if (event.data && event.data.type === 'SKIP_WAITING') {
		self.skipWaiting();
	}
});

// Handle navigation requests with a network-first strategy
const navigationRoute = new NavigationRoute(createHandlerBoundToURL('/'), {
	allowlist: [/^\/$/],
	denylist: [/^\/api\//]
});

registerRoute(navigationRoute);

// Background sync for offline data
self.addEventListener('sync', (event) => {
	if (event.tag === 'sync-tabs') {
		event.waitUntil(syncTabs());
	}
});

async function syncTabs() {
	// This would sync any offline changes when back online
	// Implementation depends on your data storage strategy
	console.log('Syncing tabs...');
}

// Push notification support (optional)
self.addEventListener('push', (event) => {
	const data = event.data?.json() ?? {};
	const title = data.title || 'TabScroll';
	const options = {
		body: data.body || 'New update available',
		icon: '/icon-192.png',
		badge: '/icon-72.png',
		data: data.url || '/'
	};

	event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', (event) => {
	event.notification.close();
	event.waitUntil(
		self.clients.matchAll({ type: 'window' }).then((clientList) => {
			for (const client of clientList) {
				if (client.url === event.notification.data && 'focus' in client) {
					return client.focus();
				}
			}
			if (self.clients.openWindow) {
				return self.clients.openWindow(event.notification.data);
			}
		})
	);
});

